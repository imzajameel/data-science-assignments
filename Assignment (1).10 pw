{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "d07fcea1-48aa-494e-bbaf-ab02f3cbbf81",
   "metadata": {},
   "outputs": [],
   "source": [
    "#Question.1 What is multithreading in python ? Why is it used ? Name the module used to handle threads in python .\n",
    "#Answer.1  Multithreading in Python refers to the concurrent execution of multiple threads within a single program. \n",
    "#A thread is a lightweight unit of execution that can run independently, allowing different parts of a program to execute\n",
    "#concurrently.\n",
    "\n",
    "#Multithreading is used to achieve parallelism and improve the overall performance and responsiveness of a program.\n",
    "#It allows for the execution of multiple tasks simultaneously, making it particularly useful in scenarios where tasks\n",
    "#can be executed independently and do not depend on each other's results.\n",
    "\n",
    "#In Python, the threading module is used to handle threads. It provides a high-level interface for creating, managing,\n",
    "#and synchronizing threads. The threading module allows you to create threads, start them, and coordinate their execution\n",
    "#through synchronization primitives like locks, conditions, semaphores, and events.\n",
    "\n",
    "#By using multithreading with the threading module, you can leverage the power of concurrency to perform tasks concurrently,\n",
    "#utilize system resources more efficiently, and create responsive applications that can handle multiple operations \n",
    "#simultaneously. However, it's important to note that due to the Global Interpreter Lock (GIL) in CPython, which allows\n",
    "#only one thread to execute Python bytecode at a time, multithreading in Python may not always result in true parallelism\n",
    "#across multiple CPU cores."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "438dc85b-2557-4e05-a2b4-89734cc5b029",
   "metadata": {},
   "outputs": [],
   "source": [
    "#Question.2 Why threading module is used ? Write the use of following functions : \n",
    "#1.activeCount()\n",
    "#2.currentThread()\n",
    "#3.enumerate()\n",
    "#Answer.2 The threading module in Python is used for creating and managing threads, allowing concurrent execution of\n",
    "#multiple tasks within a single program. It provides a high-level interface for working with threads, offering various\n",
    "#functions and classes to handle thread creation, synchronization, and management.\n",
    "\n",
    "#1.activeCount() : \n",
    "#the activeCount() function is used to get the number of currently alive thread objects. It returns the number of Thread\n",
    "#objects that are currently running or alive.\n",
    "\n",
    "#2.currentThread() : \n",
    "#The currentThread() function is a method available in the threading module in Python. It is used to get a reference to the\n",
    "#current Thread object corresponding to the calling thread. It returns an instance of the Thread class representing the \n",
    "#currently executing thread.\n",
    "\n",
    "#3.enumerate() : \n",
    "#The enumerate() function is a method available in the threading module in Python. It is used to get a list of all Thread\n",
    "#objects currently active or running."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "28852c5d-2284-4c98-8ad1-709bce0aea8b",
   "metadata": {},
   "outputs": [],
   "source": [
    "#Question.3 Explain the following functions : \n",
    "#1. run()\n",
    "#2. start()\n",
    "#3. join()\n",
    "#4. isAlive()\n",
    "#Answer.3 : \n",
    "#1. run() : The run() function is a method that is part of the Thread class in Python's threading module. It is used to\n",
    "#define the code that will be executed by a thread when it starts.\n",
    "#To use the run() function, you need to create a subclass of the Thread class and override the run() method with your\n",
    "#desired thread logic. The run() method should contain the code that you want the thread to execute when it starts.\n",
    "\n",
    "#When the start() method of a Thread object is called, it internally calls the run() method. This initiates the execution of \n",
    "#the thread and executes the code defined within the run() method.\n",
    "\n",
    "#By overriding the run() method, you can customize the behavior of the thread and specify the actions it should perform.\n",
    "#It provides a way to encapsulate the specific logic or tasks that the thread needs to execute.\n",
    "\n",
    "#It's important to note that you should not call the run() method directly. Instead, you should call the start() method\n",
    "#on the Thread object, which internally triggers the execution of the run() method in a separate thread.\n",
    "\n",
    "#2.start() : In Python's threading module, the start() method is used to start the execution of a thread. It initiates the\n",
    "#thread's execution by calling its run() method in a separate thread of control.\n",
    "#In Python's threading module, the start() method is used to start the execution of a thread. It initiates the thread's\n",
    "#execution by calling its run() method in a separate thread of control.\n",
    "\n",
    "#When you call the start() method on a Thread object, it does the following:\n",
    "\n",
    "#Allocates system resources and prepares the thread for execution.\n",
    "#Calls the run() method of the thread internally.\n",
    "#The start() method returns immediately after initiating the thread's execution. It does not wait for the thread to complete \n",
    "#its execution. Instead, the thread runs independently in the background, allowing other parts of the program to continue\n",
    "#executing.\n",
    "\n",
    "#3. join() :  In Python's threading module, the join() method is used to wait for a thread to complete its execution before \n",
    "#proceeding with the rest of the program. It allows you to synchronize the execution of threads and ensures that the main \n",
    "#thread or other threads wait for a specific thread to finish.\n",
    "\n",
    "#When you call the join() method on a Thread object, it blocks the calling thread until the thread being joined terminates.\n",
    "#If the thread has already completed its execution, the join() method returns immediately. Otherwise, it waits until the \n",
    "#thread finishes its execution.\n",
    "\n",
    "#4.isAlive() : The isAlive() method is a function available in the threading module in Python. It is used to check whether\n",
    "#a thread is currently alive or running.\n",
    "#When you call the isAlive() method on a Thread object, it returns True if the thread is currently alive or running,\n",
    "#and False otherwise."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "4dc2be79-f980-4ccf-a0ca-ca99f512dd58",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "List of squares: [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n",
      "List of cubes: [1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]\n",
      "Done\n"
     ]
    }
   ],
   "source": [
    "#Question.4 Write a python program to create two threads.Thread one must print the list of squares \n",
    "#and thread  two must print the list of cubes.\n",
    "#Answer.4 : \n",
    "import threading\n",
    "\n",
    "def print_squares():\n",
    "    squares = [i**2 for i in range(1, 11)]\n",
    "    print(\"List of squares:\", squares)\n",
    "\n",
    "def print_cubes():\n",
    "    cubes = [i**3 for i in range(1, 11)]\n",
    "    print(\"List of cubes:\", cubes)\n",
    "\n",
    "# Create thread one for printing squares\n",
    "thread_one = threading.Thread(target=print_squares)\n",
    "\n",
    "# Create thread two for printing cubes\n",
    "thread_two = threading.Thread(target=print_cubes)\n",
    "\n",
    "# Start both threads\n",
    "thread_one.start()\n",
    "thread_two.start()\n",
    "\n",
    "# Wait for both threads to finish\n",
    "thread_one.join()\n",
    "thread_two.join()\n",
    "\n",
    "print(\"Done\")\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "bc3eec3e-2d6d-4cc7-a7da-e6d218f078e5",
   "metadata": {},
   "outputs": [],
   "source": [
    "#Question.5 State advantages and disadvantages of multithreading .\n",
    "#Answer.5 : \n",
    "#Advantages of Multithreading:\n",
    "\n",
    "#Increased Responsiveness: Multithreading allows a program to remain responsive even when performing tasks that may take\n",
    "#some time to complete. By running computationally intensive or time-consuming tasks in separate threads, the main thread\n",
    "#can continue executing other operations, ensuring a more responsive user interface.\n",
    "\n",
    "#Improved Performance: Multithreading can lead to improved performance, especially in situations where multiple tasks can \n",
    "#be executed simultaneously. By utilizing multiple threads, a program can make efficient use of available resources, such as\n",
    "#CPU cores, and achieve better overall performance.\n",
    "\n",
    "#Enhanced Resource Sharing: Threads within a process can share the same memory space, allowing them to easily exchange\n",
    "#data and share resources. This enables efficient communication and data sharing between threads, simplifying the development\n",
    "#of certain applications.\n",
    "\n",
    "#Simplified Program Structure: Multithreading can simplify the structure of a program by dividing complex tasks into smaller,\n",
    "#manageable threads. This can make the code more modular, readable, and maintainable.\n",
    "\n",
    "#Disadvantages of Multithreading:\n",
    "\n",
    "#Complexity of Synchronization: When multiple threads access shared resources concurrently, synchronization is required\n",
    "#to ensure data integrity and prevent race conditions. Managing thread synchronization can be complex and error-prone, \n",
    "#introducing challenges such as deadlocks and resource contention.\n",
    "\n",
    "#Increased Debugging Complexity: Debugging multithreaded programs can be more challenging than single-threaded programs. \n",
    "#Issues like thread synchronization errors, race conditions, and deadlock scenarios may occur, making it harder to identify \n",
    "#and fix bugs.\n",
    "\n",
    "#Potential for Performance Overhead: In certain scenarios, the overhead of thread creation, context switching, and\n",
    "#synchronization can outweigh the benefits of multithreading. It is crucial to carefully design and profile a multithreaded \n",
    "#application to ensure that the performance gains outweigh the associated costs.\n",
    "\n",
    "#Reduced Determinism: Multithreading introduces non-determinism, meaning the order of thread execution and the timing of \n",
    "#operations become less predictable. This lack of determinism can make program behavior harder to reason about and can lead to\n",
    "#subtle bugs that are difficult to reproduce and debug.\n",
    "\n",
    "#It's important to carefully consider the advantages and disadvantages of multithreading in the context of your specific\n",
    "#application. Multithreading can be highly beneficial for certain types of tasks, but it also introduces complexities that\n",
    "#need to be managed effectively to ensure the stability and correctness of the program.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "b77e2cef-18a5-496d-8668-130fe8196488",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Counter: 200000\n"
     ]
    }
   ],
   "source": [
    "#Question.6 Explain deadlocks and race conditions.\n",
    "#Answer.6 : \n",
    "#Deadlock:\n",
    "#Deadlock is a situation where multiple threads or processes are stuck and unable to proceed because each is waiting \n",
    "#for a resource that another thread or process holds. It's like a standstill where everyone is waiting for someone else to\n",
    "#move.\n",
    "\n",
    "#In Python, a common scenario for a deadlock is when two threads acquire locks in a different order. Let's say Thread A \n",
    "#holds Lock 1 and wants Lock 2, while Thread B holds Lock 2 and wants Lock 1. Both threads wait indefinitely for the other\n",
    "#thread to release the lock they need, resulting in a deadlock.\n",
    "\n",
    "#Here's a simple Python code example that illustrates a deadlock scenario:\n",
    "\n",
    "#import threading\n",
    "\n",
    "lock1 = threading.Lock()\n",
    "lock2 = threading.Lock()\n",
    "\n",
    "def thread_a():\n",
    "    lock1.acquire()\n",
    "    lock2.acquire()\n",
    "    # Perform some task\n",
    "    lock2.release()\n",
    "    lock1.release()\n",
    "\n",
    "def thread_b():\n",
    "    lock2.acquire()\n",
    "    lock1.acquire()\n",
    "    # Perform some task\n",
    "    lock1.release()\n",
    "    lock2.release()\n",
    "\n",
    "thread1 = threading.Thread(target=thread_a)\n",
    "thread2 = threading.Thread(target=thread_b)\n",
    "\n",
    "thread1.start()\n",
    "thread2.start()\n",
    "\n",
    "#In this example, both Thread A and Thread B try to acquire locks in a different order, causing a deadlock. Thread A holds\n",
    "#Lock 1 and waits for Lock 2, while Thread B holds Lock 2 and waits for Lock 1. Neither thread can proceed because they're \n",
    "#waiting for the other thread to release the lock they need.\n",
    "\n",
    "#Race conditions :  \n",
    "#Race conditions are the conditions that occurs when multiple threads access and modify shared data simultaneously,\n",
    "#leading to unpredictable and incorrect results. It's like a race between threads where the outcome depends on the timing \n",
    "#and order of execution.\n",
    "\n",
    "#In Python, a race condition can happen when multiple threads try to update a shared variable without proper synchronization.\n",
    "#Let's consider a simple example where two threads increment a shared counter variable:   \n",
    "\n",
    "import threading\n",
    "\n",
    "counter = 0\n",
    "\n",
    "def increment():\n",
    "    global counter\n",
    "    for _ in range(100000):\n",
    "        counter += 1\n",
    "\n",
    "thread1 = threading.Thread(target=increment)\n",
    "thread2 = threading.Thread(target=increment)\n",
    "\n",
    "thread1.start()\n",
    "thread2.start()\n",
    "\n",
    "thread1.join()\n",
    "thread2.join()\n",
    "\n",
    "print(\"Counter:\", counter)\n",
    "\n",
    "#In this example, both threads increment the counter variable 100,000 times. However, due to the concurrent execution of\n",
    "#threads, a race condition occurs. As a result, the final value of counter may vary each time you run the program because\n",
    "#both threads try to update the counter simultaneously, causing unpredictable and incorrect results.\n",
    "\n",
    "#To prevent deadlocks and race conditions in Python, you can use synchronization mechanisms like locks, semaphores, or \n",
    "#threading primitives provided by the threading module. These mechanisms help ensure proper coordination and access to shared \n",
    "#resources, avoiding issues like deadlocks and race conditions."
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.8"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
